[{"content":"","date":null,"permalink":"/","section":"nllptr's exceptions","summary":"","title":"nllptr's exceptions"},{"content":"","date":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":null,"permalink":"/tags/alacritty/","section":"Tags","summary":"","title":"Alacritty"},{"content":"For the longest time, I haven\u0026rsquo;t cared too much about keeping my own set of \u0026ldquo;dotfiles\u0026rdquo; (or configuration files) for software that I commonly use. Instead, I\u0026rsquo;ve preferred to use software with good defaults and tried to learn those defaults.\nRecently, as I have gotten more into home labbing, I\u0026rsquo;ve had the need to set up the same software on multiple hosts. As a consequence of this, I created a repo for the single purpose of comitting my configuration files so that they could be used on multiple machines.\nMy first iteration on this was to just put the files in a .config folder, and then write a script that would put the files in the right place on the host machine. Whenever I had updated my files in in the git repo, I would need to run the script to overwrite the previous version.\nAs one does, I watched a lot of YouTube videos on the topic, and soon discovered GNU Stow. It basically does what my script did, but in a cleaner way. In short, Stow creates a symlink for every file in my folder, \u0026ldquo;one level up\u0026rdquo;. This means that I don\u0026rsquo;t have to run some sort of update script in order to copy my changes from the local git repo to their destination.\nWith my custom script, I had to hard code the source and destination to some extent (I\u0026rsquo;m no shell scripting pro). Somewhere along the process, I realized that it was only a matter of time before my update script would get out of hand.\nStow on the other hand, just creates symlinks to match whatever file structure you have in your repo.\nSome consequences #Clear process #As I mentioned in the previous section - I like good defaults and conventions. With the assumptions Stow makes, I have a clear process to adhere to whenever I set up a new environment.\nInstall Stow Clone my dotfile repo to the home folder Run Stow from the repo root Hunger for more #Once this very clear workflow was established, I found myself more eager to add to it. I\u0026rsquo;ve moved more and more of my commonly used applications into Stow.\nOne of the greatest wins was that I finally made the decision to clean up my terminal config. Previously I used oh-my-zsh. The reason? Good defaults. But over time, as I\u0026rsquo;ve added to my .zshrc, I\u0026rsquo;ve found my terminal to become slower and slower. It\u0026rsquo;s not by much, but it\u0026rsquo;s noticable. Firing up a new terminal to make a quick change is annoying when you\u0026rsquo;re forced to wait for a few seconds just for the prompt to become responsive. Yes, I could take the time to clean it up, but with all of that out-of-the-box configuration that oh-my-zsh provides, it\u0026rsquo;s hard to know exactly what causes the issues.\nA good outcome of this shell overhaul was that I could throw oh-my-zsh away completely. That by itself got rid of my lag. But I also found Alacritty, a super snappy terminal emulator, that has now replaced my previous go to solution - iTerm2.\nOf course, both the .zshrc and the Alacritty config goes into the dotfiles repo.\nWhen I saw how much snappier my terminal could get, and as I now had my config files under control, I started looking at other places where I could improve my personal toolbox. Text editors is a classic use case, so soon I found myself building out a neovim config.\nNew requirements emerge #So now that I\u0026rsquo;ve stared building my dotfiles repo, one idea gnaws in the back of my mind: this needs to be usable everywhere, otherwise I\u0026rsquo;m wasting my time. So whenever I pick new software, I give preference to software that is cross-platform. If Windows is not on the list of supported platforms, that\u0026rsquo;s one excpetion I\u0026rsquo;m willing to make.\nThis is one reason that I really like Alacritty. It\u0026rsquo;s cross platform. My previous favorite, iTerm2, made me depend on iTerm2 specific behavior. The second I moved into a Linux environment, I would sometimes get caught by unexpected behaviors, usually related to special modifier keys, which Macs have in excess.\nAnother nice-to-have is that the application is configurable from the .config folder. It simply makes for a more tidy folder structure in your home directory. It\u0026rsquo;s not a hard requirement, but just a preference.\nThe long term #My previous stance - prefer good defaults, avoid all customization - has taken the backseat, and I attribute it all to Stow. I didn\u0026rsquo;t really want to maintain a dotfiles repo if I still had to wrestle with the tedium of manually putting those files in the right place. Mostly because of the extra cognitive load of updating my config files. I would have to make the change, and see that it works in the application, then copy those config changes into my repo. Too much. But with stow, I edit my config in the local repo, and the changes are reflected in the applications thanks to Stow\u0026rsquo;s symlinking.\nSo what does this mean long term? It means that I can take the time to customize my tools. As a software engineer, there are tons of little optimizations to be made. Before Stow, I didn\u0026rsquo;t want to make that time investment, because I couldn\u0026rsquo;t manage those optimizations in a good way. But now I can.\nI\u0026rsquo;m not the first to make the analogy, but just as a wood worker takes pride in keeping their workshop clean and their tools in the right place, so can we hackers keep our config files in order. Just as the wood worker experiments with the correct blade angle for their hand plane, so we hackers experiment with tool configurations.\nAnd we have something the wood workers don\u0026rsquo;t. We have git :)\nhttps://www.gnu.org/software/stow/\n","date":"2024-03-11","permalink":"/posts/gnu-stow/","section":"Posts","summary":"For the longest time, I haven\u0026rsquo;t cared too much about keeping my own set of \u0026ldquo;dotfiles\u0026rdquo; (or configuration files) for software that I commonly use.","title":"Gnu Stow"},{"content":"","date":null,"permalink":"/tags/neovim/","section":"Tags","summary":"","title":"Neovim"},{"content":"","date":null,"permalink":"/tags/stow/","section":"Tags","summary":"","title":"Stow"},{"content":"","date":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"A really simple one, this is, but oh how it blew my mind! In your JavaScript code, insert debugger; where you might want a breakpoint. Refresh your browser with dev tools open, and voila! The debugger pauses execution at the debugger statement.\nUsing the debugger statement is less typing than console logging, and you get all the variables that are in scope. You also get the ability to step and can see how stuff changes. When console logging it might be hard to know when stuff happens, and that might lead to a wrong idea of what\u0026rsquo;s actually happening.\nI\u0026rsquo;m a keyboard person. If I can avoid mousing around, I\u0026rsquo;ll avoid it. Using the debugger statement, I can edit my code, alt+tab to the browser, refresh and see what\u0026rsquo;s up, and alt+tab back to the editor. I don\u0026rsquo;t need the mouse unless I want to start stepping through the code, and that probably means taking a break from editing anyways.\n","date":"2019-09-25","permalink":"/posts/debugger/","section":"Posts","summary":"A really simple one, this is, but oh how it blew my mind!","title":"debugger;"},{"content":"","date":null,"permalink":"/tags/javascript/","section":"Tags","summary":"","title":"JavaScript"},{"content":"","date":null,"permalink":"/categories/old-blog/","section":"Categories","summary":"","title":"Old Blog"},{"content":"Usage #new is used to create new instances of objects with the help of constructor functions. While taking a look at prototypes, I ran into the new keyword, and how it relates to the function.prototype property. I thought that it might be a good exercise to look into how new works.\nUnder the hood #According to MDN, there are three steps taken when using new:\nA new object is created. If the constructor function has its prototype property set to some object, the newly created object will inherit from that prototype. The constructor function is called with the new object bound to this. The result of the new ... expression will be what ever is returned by the constructor function. If nothing is returned, our newly created object (bound to this) will be used instead. It is usually the case that nothing is explicitly returned from constructor functions, but we have the option to do so. Noteworthy #If the constructor has no parameters, new Foo will be equal to new Foo().\nExample #const myPrototype = { protoProperty = \u0026#34;protolicious!\u0026#34; } function MyConstructor() { this.message = \u0026#34;hello\u0026#34; } MyConstructor.prototype = myPrototype const myInstance = new MyConstructor myInstance.message // \u0026#34;hello\u0026#34; myInstance.protoProperty // \u0026#34;protolicious!\u0026#34; ","date":"2019-09-20","permalink":"/posts/javascript-new/","section":"Posts","summary":"Usage #new is used to create new instances of objects with the help of constructor functions.","title":"Javascript's `new` keyword"},{"content":"Objects and the prototype chain #In JavaScript there is only one construct - objects. Objects have a property that links that object to its prototype. That prototype in turn has a link to its prototype, and so this chain goes on until someone has a prototype of null This is what we know as the \u0026ldquo;prototype chain\u0026rdquo;. The most common \u0026ldquo;top level object\u0026rdquo; is Object, which has a null prototype. Not sure, but the wording at Inheritance and the prototype chain leads me to believe that there are other top level objects.\nJavaScript inheritance #When we access a property on an object, JavaScript first looks at that object\u0026rsquo;s \u0026ldquo;own properties\u0026rdquo;. If the property is not found, the next step is to take a look at that object\u0026rsquo;s prototype to see if it\u0026rsquo;s present there. If not, then we move up the prototype chain either until the property is found or until we reach the end of the chain.\nAccessing #Since ECMAScript 2015, we access the prototype by using Object.getPrototypeOf(myObject) or Object.setPrototypeOf(myObject) respectively. We could also use myObject.__proto__, which is implemented by many browsers (but NOT standard).\nPitfall #Do not confuse __proto__ and Object.getPrototypeOf() with the property func.prototype. Note that this is a property that exists on functions. When using that function as a constructor, JavaScript looks to the prototype property to see what should be the pototype of the created object.\nconst myProto = { protoProp: \u0026#34;hello\u0026#34; } function MyConstructor(thing) { this.thing = thing } MyConstructor.prototype = myProto MyInstance = new MyConstructor(\u0026#34;thing\u0026#34;) // MyInstance would look like this: MyConstructor { thing: \u0026#34;thing\u0026#34; __proto__ : { protoProp: \u0026#34;hello\u0026#34;, } } ","date":"2019-09-19","permalink":"/posts/javascript-prototypes/","section":"Posts","summary":"Objects and the prototype chain #In JavaScript there is only one construct - objects.","title":"Javascript Prototypes"},{"content":"I just started looking at Rust. I\u0026rsquo;ve been putting it off for a while since I\u0026rsquo;ve been focusing on Go, and haven\u0026rsquo;t really had the bandwidth to learn another language. But yesterday I was inspired by a colleague of mine. And so I present my initial thoughts.\nGetting started #When I first started with Go, it could be a bit of a hassle to get things set up, with GOPATH and such. With Rust I felt it was way easier. Though, I will have to take into account that I\u0026rsquo;m comparing apples to oranges. Setting up Go these days is a bit easier, and I have no idea wether Rust has been difficult to set up in the past. But looking at it here and now, it was only a matter of installing rustup, and things just work.\nLearning Rust #One thing that got me excited about Go was the (in my opinion) good and easy-to-read documentation of the standard library. It seems that Rust has taken it a few steps further. Similar to Go, Rust comes with utilities to browse documentation locally in your web browser. This is a huge deal for me, since most of my learning time is on the commuter train with an unstable Internet connection.\nI haven\u0026rsquo;t really looked into it yet, but it seems that Rust has some really neat ways of documenting ones code, and generating web docuementation from it. Another super sweet feature is that the documentation comes with an e-book, usually just called \u0026ldquo;the book\u0026rdquo;.\nPackage management #One place where Rust seems to out-shine Go is in the space of package management. I\u0026rsquo;ve been happy so far with Go\u0026rsquo;s way of doing things, since I\u0026rsquo;ve usually only done small projects without complex dependencies. The go get command was simple and worked. Vendoring worked. But at this point the Go team has started working on ways to better manage dependencies (such as modules). Rust seems to give you a lot of this out of the box. The tool cargo is used to manage your dependencies, and seems to do a good job. Please note that these are just my initial thoughts. I\u0026rsquo;m sure that I with time will find things that I wish were different. It\u0026rsquo;s not a perfect world.\nStandard libarary #The great standard library of Go is something I love. Same with Python. I don\u0026rsquo;t know yet, but my initial impressions (which are just that - impressions) are that Rust does not have the same rich standard library. For example - a tutorial in \u0026ldquo;the book\u0026rdquo; shows you how to write a number guessing game. This requires generating a random number, functionality that I\u0026rsquo;ve come to take for granted that it should exist in the standard library. This is not the case in Rust. However, there is a library (written by the Rust team I believe) that is easily installed with cargo.\nEnumerated types #I\u0026rsquo;ve come to get accustomed to Go\u0026rsquo;s multiple return values. Especially when it comes to error handling. It\u0026rsquo;s very common practice that the last return value of a function is an error value which you check right after the function returns to make sure everything went ok. Rust instead uses enumerated types. One such type is the Result type, which is an enumerated type. After calling a function that returns an enumerated type you check the return value. The nice thing about checking (or \u0026ldquo;matching\u0026rdquo;) enumerated types is that the compiler forces you to check every case. That way, you can know at compile time that you didn\u0026rsquo;t leave any cases out.\nConclusion #Rust seems to have a lot going for it. I\u0026rsquo;m curious, but probably not curious enough to keep digging. Especially since I\u0026rsquo;m mostly in the web API space, which is where Go really shines. I\u0026rsquo;ll probably revisit Rust at some point, but right now, I have other things that require my attention.\n","date":"2019-09-11","permalink":"/posts/rust-first-impressions/","section":"Posts","summary":"I just started looking at Rust.","title":"First impression of Rust"},{"content":"This is just a reminder to myself. When you start new projects;\nKEEP IT SIMPLE, STUPID! #That\u0026rsquo;s all.\n","date":"2019-08-29","permalink":"/posts/kiss/","section":"Posts","summary":"This is just a reminder to myself.","title":"Keeping it simple"}]